# -*- coding: utf-8 -*-
"""Predicting Gold Prices Using Support Vector Machine (SVM) Regression.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cFbdIAzvzZpaewhQ2XbTLvPQfeOaiwcV
"""

import pandas as pd
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.preprocessing import StandardScaler
from sklearn.svm import SVR
from sklearn.metrics import mean_squared_error, r2_score
import matplotlib.pyplot as plt

# Load the data
data = pd.read_csv('gold_prices.csv')

data

# Preprocessing
# Convert date to datetime and set it as index
data['Date'] = pd.to_datetime(data['Date'])
data.set_index('Date', inplace=True)

# Handle missing values if any (e.g., fill with mean)
data.fillna(data.mean(), inplace=True)

data

# Feature and target variables
X = data.drop(columns=['gold_oz_usd_price'])
y = data['gold_oz_usd_price']

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

X

y

# Feature scaling
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

# SVM regression model
svr = SVR()

# Hyperparameter tuning using GridSearchCV
param_grid = {
    'C': [0.1, 1, 10, 100],
    'epsilon': [0.1, 0.2, 0.5, 0.3],
    'kernel': ['linear', 'poly', 'rbf', 'sigmoid']
}

grid_search = GridSearchCV(estimator=svr, param_grid=param_grid, cv=5, scoring='neg_mean_squared_error')
grid_search.fit(X_train, y_train)

# Best parameters from GridSearchCV
best_params = grid_search.best_params_
print(f"Best parameters: {best_params}")

# Train the model with the best parameters
best_svr = SVR(C=best_params['C'], epsilon=best_params['epsilon'], kernel=best_params['kernel'])
best_svr.fit(X_train, y_train)

# Predictions
y_pred_train = best_svr.predict(X_train)
y_pred_test = best_svr.predict(X_test)

# Evaluation
train_rmse = mean_squared_error(y_train, y_pred_train, squared=False)
test_rmse = mean_squared_error(y_test, y_pred_test, squared=False)
r2 = r2_score(y_test, y_pred_test)

print(f"Train RMSE: {train_rmse}")
print(f"Test RMSE: {test_rmse}")
print(f"R^2 Score: {r2}")

# Predicting a single new value
# Create a new sample (assuming it has the same structure as your training data)
new_sample = pd.DataFrame({
    'gold_kg_usd_price': [45000],
    'gold_oz_gbp_price': [1200],
    'gold_kg_gbp_price': [38000],
    'gold_oz_eur_price': [1100],
    'gold_kg_eur_price': [35000]
})

# Scale the new sample
new_sample_scaled = scaler.transform(new_sample)

# Predict
new_prediction = best_svr.predict(new_sample_scaled)
print(f"Predicted gold_oz_usd_price: {new_prediction[0]}")

# Plotting the results
plt.figure(figsize=(10, 6))
plt.plot(y_test.index, y_test.values, label='Actual Price')
plt.plot(y_test.index, y_pred_test, label='Predicted Price')
plt.xlabel('Date')
plt.ylabel('Gold Price (USD)')
plt.title('Actual vs Predicted Gold Prices')
plt.legend()
plt.show()